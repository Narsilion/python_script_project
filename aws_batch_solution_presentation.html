<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AWS Batch vs ECS Scheduled Tasks</title>
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --ink: #112240;
      --muted: #4b5b7a;
      --primary: #0b6aa2;
      --accent: #ff8a00;
      --ok: #2b8a3e;
      --line: #dbe3ef;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Avenir Next", "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 85% 15%, #d8ecff 0, transparent 30%),
        radial-gradient(circle at 15% 85%, #ffe8cc 0, transparent 35%),
        var(--bg);
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .deck {
      width: min(1100px, 100%);
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: 0 20px 50px rgba(17, 34, 64, 0.15);
      overflow: hidden;
    }

    .topbar {
      padding: 14px 22px;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(90deg, #ffffff 0%, #f2f7ff 100%);
    }

    .brand {
      font-weight: 700;
      letter-spacing: 0.4px;
      color: var(--primary);
    }

    .meta {
      color: var(--muted);
      font-size: 14px;
    }

    .slide {
      display: none;
      min-height: 580px;
      padding: 56px 64px;
      animation: fade 0.4s ease;
    }

    .slide.active { display: block; }

    @keyframes fade {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    h1, h2 {
      margin: 0 0 16px;
      line-height: 1.15;
      letter-spacing: 0.2px;
    }

    h1 { font-size: clamp(34px, 4.5vw, 52px); }
    h2 { font-size: clamp(28px, 3.5vw, 40px); }

    p {
      font-size: 20px;
      margin: 0 0 14px;
      color: var(--muted);
      max-width: 900px;
    }

    ul {
      margin: 12px 0 0;
      padding-left: 22px;
      font-size: 20px;
      color: var(--ink);
      line-height: 1.45;
    }

    li { margin: 8px 0; }

    .pill {
      display: inline-block;
      padding: 7px 12px;
      border-radius: 999px;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #083451;
      background: #dff3ff;
      border: 1px solid #b6e2ff;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 18px;
      margin-top: 20px;
    }

    .box {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 18px;
      background: #fbfdff;
    }

    .box h3 {
      margin: 0 0 8px;
      font-size: 22px;
    }

    .box p {
      font-size: 18px;
      margin: 0;
    }

    .chosen {
      border: 2px solid #ffc988;
      background: #fff8ef;
    }

    .ok { color: var(--ok); font-weight: 700; }

    .timeline {
      margin-top: 22px;
      border-left: 3px solid var(--line);
      padding-left: 18px;
    }

    .timeline p {
      margin: 0 0 14px;
      font-size: 18px;
      color: var(--ink);
    }

    .controls {
      border-top: 1px solid var(--line);
      padding: 12px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #fbfdff;
    }

    button {
      border: 1px solid var(--line);
      background: white;
      color: var(--ink);
      border-radius: 10px;
      padding: 9px 14px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }

    button:hover { border-color: var(--primary); color: var(--primary); }

    .count { font-size: 14px; color: var(--muted); }

    @media (max-width: 820px) {
      .slide { padding: 34px 22px; min-height: 520px; }
      p, ul { font-size: 18px; }
      .grid-2 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="deck" aria-live="polite">
    <div class="topbar">
      <div class="brand">Solution Presentation</div>
      <div class="meta">AWS Batch vs ECS Scheduled Tasks</div>
    </div>

    <section class="slide active">
      <span class="pill">Slide 1</span>
      <h1>Containerized Job Execution on AWS</h1>
      <p>Decision summary for implementing periodic or on-demand batch processing of a Python container workload.</p>
      <ul>
        <li>Goal: reliable execution, observability, and low operational overhead.</li>
        <li>Scope: AWS-native options, focused on Batch and ECS Scheduled Tasks.</li>
        <li>Outcome: AWS Batch selected as the primary orchestration layer.</li>
      </ul>
    </section>

    <section class="slide">
      <span class="pill">Slide 2</span>
      <h2>Current Task</h2>
      <p>Run a Dockerized Python script as a repeatable workload with clear status tracking and CloudWatch logs.</p>
      <ul>
        <li>Workload type: non-interactive job (not a long-running API service).</li>
        <li>Execution pattern: scheduled or triggered runs, potentially multiple jobs in parallel.</li>
        <li>Operational needs: retries, controlled resource sizing, and easy submission for users.</li>
      </ul>
    </section>

    <section class="slide">
      <span class="pill">Slide 3</span>
      <h2>Why AWS</h2>
      <ul>
        <li>I have the most hands-on experience in AWS, reducing delivery risk and implementation time.</li>
        <li>AWS provides managed services that directly match this use case: ECR, Batch/ECS, IAM, and CloudWatch.</li>
        <li>Security and access can be controlled with IAM roles and scoped policies for job submission.</li>
        <li>The platform supports future growth from simple runs to larger parallel processing.</li>
      </ul>
    </section>

    <section class="slide">
      <span class="pill">Slide 4</span>
      <h2>Possible Solutions</h2>
      <div class="grid-2">
        <div class="box">
          <h3>ECS Scheduled Tasks</h3>
          <p>Simple EventBridge cron/rate trigger to run a task definition on Fargate.</p>
          <ul>
            <li>Best for straightforward cron jobs.</li>
            <li>Lower setup complexity for basic schedules.</li>
            <li>Less native batch orchestration (queueing/dependencies).</li>
          </ul>
        </div>
        <div class="box chosen">
          <h3>AWS Batch <span class="ok">(Chosen)</span></h3>
          <p>Managed batch scheduler with job queues and Fargate compute environments.</p>
          <ul>
            <li>Built-in job queueing and execution control.</li>
            <li>Native retries, timeouts, and better batch semantics.</li>
            <li>Scales cleanly for concurrent jobs and future growth.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="slide">
      <span class="pill">Slide 5</span>
      <h2>Why Batch Over ECS Scheduled Tasks</h2>
      <ul>
        <li>The workload is job-oriented, so queue-first orchestration is a better fit.</li>
        <li>If runs overlap or volume grows, Batch handles backlog and concurrency more naturally.</li>
        <li>Retry and failure behavior is managed at the job layer instead of custom glue logic.</li>
        <li>Batch still uses Fargate under the hood, so we keep serverless container operations.</li>
      </ul>
    </section>

    <section class="slide">
      <span class="pill">Slide 6</span>
      <h2>Why Fargate Over EC2</h2>
      <ul>
        <li>Fargate is serverless, so there are no EC2 instances to provision, patch, or maintain.</li>
        <li>The team can focus on job logic and orchestration instead of node lifecycle operations.</li>
        <li>Scaling is managed by AWS at the task level, which fits an event-driven batch workload.</li>
        <li>This reduces operational overhead while keeping strong isolation for each job run.</li>
      </ul>
    </section>

    <section class="slide">
      <span class="pill">Slide 7</span>
      <h2>Current Implementation Description</h2>
      <p>Implemented in <code>python_script_project</code> with Docker, ECR, Terragrunt, and Terraform module-based infra.</p>
      <div class="timeline">
        <p><strong>Container:</strong> Python app built from <code>Dockerfile</code> and pushed to ECR (<code>python-script:v1.0</code>).</p>
        <p><strong>Infrastructure:</strong> Terragrunt stack deploys Batch compute environment (<code>FARGATE_SPOT</code>), job queue, job definition, IAM roles, and log group.</p>
        <p><strong>Compute choice:</strong> <code>FARGATE_SPOT</code> is selected for demo purposes to reduce cost. For production load, <code>FARGATE</code> would be preferred for higher availability and lower interruption risk.</p>
        <p><strong>Runtime config:</strong> Job command is <code>python /app/main.py</code> with 0.25 vCPU and 512 MB memory.</p>
        <p><strong>Operations:</strong> Jobs submitted with AWS CLI, status checked via Batch APIs, logs viewed in CloudWatch (<code>/aws/batch/job/python-script</code>).</p>
      </div>
    </section>

    <div class="controls">
      <button id="prev" aria-label="Previous slide">Previous</button>
      <div id="count" class="count">1 / 7</div>
      <button id="next" aria-label="Next slide">Next</button>
    </div>
  </main>

  <script>
    const slides = Array.from(document.querySelectorAll('.slide'));
    const count = document.getElementById('count');
    const prev = document.getElementById('prev');
    const next = document.getElementById('next');
    let index = 0;

    function render() {
      slides.forEach((slide, i) => {
        slide.classList.toggle('active', i === index);
      });
      count.textContent = `${index + 1} / ${slides.length}`;
      prev.disabled = index === 0;
      next.disabled = index === slides.length - 1;
    }

    prev.addEventListener('click', () => {
      if (index > 0) {
        index -= 1;
        render();
      }
    });

    next.addEventListener('click', () => {
      if (index < slides.length - 1) {
        index += 1;
        render();
      }
    });

    window.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowRight' || event.key === 'PageDown') {
        if (index < slides.length - 1) {
          index += 1;
          render();
        }
      }
      if (event.key === 'ArrowLeft' || event.key === 'PageUp') {
        if (index > 0) {
          index -= 1;
          render();
        }
      }
    });

    render();
  </script>
</body>
</html>
